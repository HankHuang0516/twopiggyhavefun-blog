---
// BusinessStatus.astro - Dynamic business status component with raw string parsing
interface Props {
    businessName?: string;
    rawHours?: string;
    permanentlyClosed?: boolean;
}

const { businessName, rawHours, permanentlyClosed } = Astro.props;
---

{permanentlyClosed ? (
    <div class="business-status closed-permanently bg-red-100 border-l-4 border-red-500 p-4 my-4 font-sans">
        <div class="flex items-center">
            <span class="text-2xl mr-3">ğŸš«</span>
            <div>
                <p class="font-bold text-red-700 text-lg">å·²æ­‡æ¥­</p>
                <p class="text-red-600">æ­¤åº—å®¶ç›®å‰å·²ä¸å†ç‡Ÿæ¥­</p>
            </div>
        </div>
    </div>
) : rawHours ? (
    <div class="business-status bg-white border border-gray-200 shadow-sm p-5 my-6 rounded-lg font-sans" id="business-hours-widget">
        <div class="flex justify-between items-start mb-3">
            <h4 class="font-bold text-gray-800 text-lg flex items-center">
                <span class="mr-2 text-xl">ğŸ•</span>
                {businessName ? `${businessName} ç‡Ÿæ¥­æ™‚é–“` : 'ç‡Ÿæ¥­è³‡è¨Š'}
            </h4>
            <!-- Dynamic Status Badge -->
            <div id="status-badge" class="px-3 py-1 rounded-full text-sm font-bold bg-gray-100 text-gray-500">
                è®€å–ä¸­...
            </div>
        </div>
        
        <!-- Raw Hours Display -->
        <div class="text-gray-600 text-base leading-relaxed p-3 bg-gray-50 rounded border border-gray-100">
            {rawHours.split(/[,ï¼Œ;ï¼›]/).map(segment => (
                <div class="mb-1 last:mb-0">{segment.trim()}</div>
            ))}
        </div>
        
        <!-- Detailed Status Message -->
        <p id="status-message" class="text-sm text-gray-500 mt-2 text-right opacity-80"></p>

        <div id="raw-hours-data" style="display:none;" data-hours={rawHours}></div>
    </div>
    
    <script>
        // Client-side parsing logic for Chinese business hours
        function parseTime(timeStr) {
            if (!timeStr) return null;
            // Clean string and handle 24h/12h separation if basic parsing fails
            // Basic format: HH:mm
            const match = timeStr.match(/(\d{1,2})[:ï¼š](\d{2})/);
            if (!match) return null;
            return parseInt(match[1]) * 60 + parseInt(match[2]);
        }

        function getCurrentDayType() {
            const day = new Date().getDay(); // 0 = Sun, 1 = Mon...
            if (day === 0 || day === 6) return 'weekend';
            return 'weekday';
        }

        function getCurrentDayChar() {
            const days = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
            return days[new Date().getDay()];
        }

        function checkStatus(rawHours) {
            const now = new Date();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            const currentDayChar = getCurrentDayChar();
            
            // Patterns
            // 1. "é€±ä¸€ï½é€±äº” 11:00-14:00"
            // 2. "æ¯æ—¥ 10:00-22:00"
            // 3. "11:00-21:00 (é€±ä¸‰å…¬ä¼‘)"
            
            let isClosedDay = false;
            
            // Check for explicit closed days first
            // regex for "é€±Xå…¬ä¼‘", "å‘¨Xå…¬ä¼‘"
            const closedMatch = rawHours.match(/é€±([ä¸€äºŒä¸‰å››äº”å…­æ—¥])\s*å…¬ä¼‘/g) || rawHours.match(/å‘¨([ä¸€äºŒä¸‰å››äº”å…­æ—¥])\s*å…¬ä¼‘/g);
            if (closedMatch) {
                closedMatch.forEach(m => {
                    if (m.includes(`é€±${currentDayChar}`) || m.includes(`å‘¨${currentDayChar}`)) {
                        isClosedDay = true;
                    }
                });
            }
            
            if (isClosedDay) return { state: 'closed-day', msg: 'ä»Šæ—¥å…¬ä¼‘' };

            // Extract all time ranges found in the string
            // Looking for HH:mm-HH:mm or HH:mm~HH:mm
            const rangeRegex = /(\d{1,2}[:ï¼š]\d{2})\s*[-~ï½]\s*(\d{1,2}[:ï¼š]\d{2})/g;
            const ranges = [];
            let match;
            
            // Very basic extraction: grab all time ranges. 
            // Improvement: associate ranges with day specifiers if possible.
            // For now, if the string implies different times for different days, this simple logic might be ambiguous.
            // But usually "Weekdays A, Weekends B" format is separable.
            
            // Refined strategy: Split by day-grouping if possible, but that's complex.
            // Global search for now: check if ANY extracted range covers current time.
            // BUT, if it says "Weekdays 9-5, Weekends 10-6", we shouldn't match the 9am on a Sunday.
            
            // Let's try to detect if we fall into a specific segment
            let relevantText = rawHours;
            
            // If text contains "å‡æ—¥" or "é€±å…­æ—¥" or "å…­æ—¥", and today is weekend, prioritize that segment?
            const isWeekend = (new Date().getDay() === 0 || new Date().getDay() === 6);
            
            if (rawHours.includes('å‡æ—¥') || rawHours.includes('å…­æ—¥') || rawHours.includes('é€±å…­æ—¥')) {
                 // Try to split logic roughly? Too risky for regex.
                 // Fallback: Just look for ALL ranges. If NOW is inside ANY range, we tentatively say Open.
                 // Unless we are sure it's a closed day.
            }

            // Improved logic: Parse all ranges then decide
            let allRanges = [];
            while ((match = rangeRegex.exec(rawHours)) !== null) {
                const s = parseTime(match[1]);
                const e = parseTime(match[2]);
                if (s !== null && e !== null) {
                    let effectiveEnd = e;
                    if (e < s) effectiveEnd += 24 * 60; // Overnight
                    allRanges.push({ start: s, end: effectiveEnd, rawStart: match[1], rawEnd: match[2] });
                }
            }
            
            allRanges.sort((a, b) => a.start - b.start);

            if (allRanges.length === 0) return { state: 'unknown', msg: 'è«‹æŸ¥çœ‹ç‡Ÿæ¥­æ™‚é–“' };

            // Check State
            for (let i = 0; i < allRanges.length; i++) {
                const r = allRanges[i];
                // Check Open
                if (currentMinutes >= r.start && currentMinutes < r.end) {
                     return { 
                         state: 'open', 
                         msg: `ç‡Ÿæ¥­ä¸­ (ç›´åˆ° ${r.rawEnd})`,
                         endTime: r.end
                     };
                }
                // Check Opening Soon (within 60m)
                if (currentMinutes < r.start && (r.start - currentMinutes) <= 60) {
                     return {
                         state: 'opening-soon',
                         msg: `å³å°‡ç‡Ÿæ¥­ (${r.rawStart} é–‹é–€)`,
                         startTime: r.start
                     };
                }
            }

            // If not open, check if there's a next range TODAY
            // Filter ranges that start after now
            const nextRange = allRanges.find(r => r.start > currentMinutes);
            
            if (nextRange) {
                // Resting between shifts
                // Calculate hours diff
                const diffMins = nextRange.start - currentMinutes;
                const diffHrs = Math.floor(diffMins / 60);
                // const diffRestMins = diffMins % 60;
                
                return { 
                    state: 'closed', 
                    msg: 'ä¼‘æ¯ä¸­', 
                    nextOpen: nextRange.rawStart 
                };
            } else {
                // No more ranges today
                return { state: 'closed-day', msg: 'ä»Šæ—¥ç‡Ÿæ¥­å·²çµæŸ' };
            }
        }

        function updateWidget() {
            const el = document.getElementById('raw-hours-data');
            if (!el) return;
            const hoursStr = el.dataset.hours;
            const badge = document.getElementById('status-badge');
            const msgEl = document.getElementById('status-message');
            
            const result = checkStatus(hoursStr);
            
                if (result.state === 'open') {
                    // ç‡Ÿæ¥­ä¸­
                    badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-green-100 text-green-700 border border-green-200';
                    badge.textContent = 'â— ç‡Ÿæ¥­ä¸­';
                } else if (result.state === 'closed-day') {
                    // å…¬ä¼‘
                    badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-gray-200 text-gray-600 border border-gray-300';
                    badge.textContent = 'ä»Šæ—¥å…¬ä¼‘';
                } else if (result.state === 'opening-soon') {
                    // å³å°‡ç‡Ÿæ¥­
                     badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-yellow-100 text-yellow-700 border border-yellow-200';
                    badge.textContent = 'å³å°‡ç‡Ÿæ¥­';
                } else if (result.state === 'closed') {
                    // ä¼‘æ¯ä¸­ (ä½†ä»Šæ—¥é‚„æœ‰ç‡Ÿæ¥­æ™‚æ®µ)
                    // Show "Resting (Open at XX:XX)" or "Resting (in X hours)"
                    // Priority: Prominent Badge with meaningful info
                    badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-orange-100 text-orange-700 border border-orange-200';
                    if (result.nextOpen) {
                        badge.textContent = `ä¼‘æ¯ä¸­ (${result.nextOpen} é–‹é–€)`;
                    } else {
                        badge.textContent = 'ä¼‘æ¯ä¸­';
                    }
                } else {
                    badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-gray-100 text-gray-500';
                    badge.textContent = 'æŸ¥çœ‹è©³æƒ…';
                }
            }
            
            if (msgEl && result.msg) {
                // Formatting message with next open time if available
                if (result.state === 'closed' && result.nextOpen) {
                     msgEl.textContent = `ä¼‘æ¯ä¸­ (é è¨ˆ ${result.nextOpen} é–‹é–€)`;
                } else {
                    msgEl.textContent = result.msg;
                }
            }
        }

        updateWidget();
        setInterval(updateWidget, 60000);
    </script>
) : null}
