---
// BusinessStatus.astro - Dynamic business status component with raw string parsing
interface Props {
    businessName?: string;
    rawHours?: string;
    permanentlyClosed?: boolean;
}

const { businessName, rawHours, permanentlyClosed } = Astro.props;
---

{permanentlyClosed ? (
    <div class="business-status closed-permanently bg-red-100 border-l-4 border-red-500 p-4 my-4 font-sans">
        <div class="flex items-center">
            <span class="text-2xl mr-3">ğŸš«</span>
            <div>
                <p class="font-bold text-red-700 text-lg">å·²æ­‡æ¥­</p>
                <p class="text-red-600">æ­¤åº—å®¶ç›®å‰å·²ä¸å†ç‡Ÿæ¥­</p>
            </div>
        </div>
    </div>
) : rawHours ? (
    <div class="business-status bg-white border border-gray-200 shadow-sm p-5 my-6 rounded-lg font-sans" id="business-hours-widget">
        <div class="flex justify-between items-start mb-3">
            <h4 class="font-bold text-gray-800 text-lg flex items-center">
                <span class="mr-2 text-xl">ğŸ•</span>
                {businessName ? `${businessName} ç‡Ÿæ¥­æ™‚é–“` : 'ç‡Ÿæ¥­è³‡è¨Š'}
            </h4>
            <!-- Dynamic Status Badge -->
            <div id="status-badge" class="px-3 py-1 rounded-full text-sm font-bold bg-gray-100 text-gray-500">
                è®€å–ä¸­...
            </div>
        </div>
        
        <!-- Raw Hours Display -->
        <div class="text-gray-600 text-base leading-relaxed p-3 bg-gray-50 rounded border border-gray-100">
            {rawHours.split(/[,ï¼Œ;ï¼›]/).map(segment => (
                <div class="mb-1 last:mb-0">{segment.trim()}</div>
            ))}
        </div>
        
        <!-- Detailed Status Message -->
        <p id="status-message" class="text-sm text-gray-500 mt-2 text-right opacity-80"></p>

        <div id="raw-hours-data" style="display:none;" data-hours={rawHours}></div>
    
    <script>
        // Client-side parsing logic for Chinese business hours
        const DAYS_MAP = {
            'æ—¥': 0, 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5, 'å…­': 6,
            'Sun': 0, 'Mon': 1, 'Tue': 2, 'Wed': 3, 'Thu': 4, 'Fri': 5, 'Sat': 6
        };

        function getDayIndex(dayChar) {
            return DAYS_MAP[dayChar] !== undefined ? DAYS_MAP[dayChar] : -1;
        }

        function parseTime(timeStr) {
            if (!timeStr) return null;
            const match = timeStr.match(/(\d{1,2})[:ï¼š](\d{2})/);
            if (!match) return null;
            return parseInt(match[1]) * 60 + parseInt(match[2]);
        }

        function isDayMatch(segment, currentDayIdx) {
            const isWeekend = currentDayIdx === 0 || currentDayIdx === 6;
            
            // Check "å¹³æ—¥" (Weekday) / "å‡æ—¥" (Weekend)
            if (segment.includes('å¹³æ—¥')) {
                if (isWeekend) return false;
            }
            if (segment.includes('å‡æ—¥') || segment.includes('å…­æ—¥') || segment.includes('é€±æœ«')) {
                if (!isWeekend) return false;
            }

            // Check Range "é€±X~é€±Y"
            const rangeMatch = segment.match(/é€±([ä¸€äºŒä¸‰å››äº”å…­æ—¥])\s*[-~ï½]\s*é€±([ä¸€äºŒä¸‰å››äº”å…­æ—¥])/);
            if (rangeMatch) {
                let startDay = getDayIndex(rangeMatch[1]);
                let endDay = getDayIndex(rangeMatch[2]);
                if (startDay !== -1 && endDay !== -1) {
                    let match = false;
                    if (startDay <= endDay) {
                        if (currentDayIdx >= startDay && currentDayIdx <= endDay) match = true;
                    } else {
                        if (currentDayIdx >= startDay || currentDayIdx <= endDay) match = true;
                    }
                    if (match) return true;
                }
            }

            const dayChars = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
            const curChar = dayChars[currentDayIdx];
            
            const hasDayKeywords = /é€±|å‘¨|æ˜ŸæœŸ|å¹³æ—¥|å‡æ—¥|é€±æœ«/.test(segment);
            if (!hasDayKeywords) return true; // No day constraints -> applies to all
            
            // If range matched, we generally returned true above if check passed.

            // Specific day check
            if (segment.includes(`é€±${curChar}`) || segment.includes(`å‘¨${curChar}`) || segment.includes(`æ˜ŸæœŸ${curChar}`)) {
                return true;
            }
            
            if (segment.includes('å¹³æ—¥') && !isWeekend) return true;
            if ((segment.includes('å‡æ—¥') || segment.includes('é€±æœ«')) && isWeekend) return true;
            
            return false;
        }

        function getTodayRanges(rawHours, currentDayIdx) {
            if (!rawHours) return [];
            
            const dayChars = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
            const curChar = dayChars[currentDayIdx];
            const closedRegex = new RegExp(`[é€±å‘¨]${curChar}\\s*å…¬ä¼‘`);
            if (closedRegex.test(rawHours)) {
                return 'CLOSED_DAY';
            }

            const segments = rawHours.split(/[,ï¼Œ;ï¼›]/);
            let activeRanges = [];
            const timeRegex = /(\d{1,2}[:ï¼š]\d{2})\s*[-~ï½]\s*(\d{1,2}[:ï¼š]\d{2})/g;
            
            for (const seg of segments) {
                if (isDayMatch(seg, currentDayIdx)) {
                    // Extract times
                    let match;
                    const localRegex = new RegExp(timeRegex);
                    while ((match = localRegex.exec(seg)) !== null) {
                        const s = parseTime(match[1]);
                        const e = parseTime(match[2]);
                        if (s !== null && e !== null) {
                            let effectiveEnd = e;
                            if (e < s) effectiveEnd += 24 * 60; 
                            activeRanges.push({ start: s, end: effectiveEnd, rawStart: match[1], rawEnd: match[2] });
                        }
                    }
                }
            }
            return activeRanges.sort((a,b) => a.start - b.start);
        }

        function checkStatus(rawHours) {
            const now = new Date();
            const currentDayIdx = now.getDay();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            
            const ranges = getTodayRanges(rawHours, currentDayIdx);
            
            if (ranges === 'CLOSED_DAY') {
                return { state: 'closed-day', msg: 'ä»Šæ—¥å…¬ä¼‘' };
            }
            
            if (ranges.length === 0) {
                if (rawHours && rawHours.length > 5) {
                     return { state: 'closed-day', msg: 'ä»Šæ—¥æœªç‡Ÿæ¥­' };
                }
                return { state: 'unknown', msg: 'è«‹æŸ¥çœ‹ç‡Ÿæ¥­æ™‚é–“' };
            }
            
            // Check Active
            for (const r of ranges) {
                if (currentMinutes >= r.start && currentMinutes < r.end) {
                    return { state: 'open', msg: `ç‡Ÿæ¥­ä¸­ (ç›´åˆ° ${r.rawEnd})`, endTime: r.end };
                }
                if (currentMinutes < r.start && (r.start - currentMinutes) <= 60) {
                    return { state: 'opening-soon', msg: `å³å°‡ç‡Ÿæ¥­ (${r.rawStart} é–‹é–€)`, startTime: r.start };
                }
            }
            
            // Check Next Open
            const next = ranges.find(r => r.start > currentMinutes);
            if (next) {
                const diffMins = next.start - currentMinutes;
                const diffHrs = Math.floor(diffMins / 60);
                const remMins = diffMins % 60;
                let timeMsg = "";
                if (diffHrs > 0) timeMsg += `${diffHrs}å°æ™‚`;
                timeMsg += `${remMins}åˆ†`;
                
                return { 
                    state: 'closed', 
                    msg: `ä¼‘æ¯ä¸­ (é‚„æœ‰${timeMsg}é–‹é–€)`, 
                    nextOpen: next.rawStart
                };
            }
            
            return { state: 'closed-day', msg: 'ä»Šæ—¥ç‡Ÿæ¥­å·²çµæŸ' };
        }

        function updateWidget() {
            const el = document.getElementById('raw-hours-data');
            if (!el) return;
            const hoursStr = el.dataset.hours;
            const badge = document.getElementById('status-badge');
            const msgEl = document.getElementById('status-message');
            
            const result = checkStatus(hoursStr);
            
            if (result.state === 'open') {
                badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-green-100 text-green-700 border border-green-200';
                badge.textContent = 'â— ç‡Ÿæ¥­ä¸­';
            } else if (result.state === 'closed-day') {
                badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-gray-200 text-gray-600 border border-gray-300';
                badge.textContent = 'ä»Šæ—¥å…¬ä¼‘';
            } else if (result.state === 'opening-soon') {
                badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-yellow-100 text-yellow-700 border border-yellow-200';
                badge.textContent = 'å³å°‡ç‡Ÿæ¥­';
            } else if (result.state === 'closed') {
                badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-orange-100 text-orange-700 border border-orange-200';
                if (result.nextOpen) {
                    badge.textContent = `ä¼‘æ¯ä¸­ (${result.nextOpen}é–‹é–€)`;
                } else {
                    badge.textContent = 'ä¼‘æ¯ä¸­';
                }
            } else {
                badge.className = 'px-3 py-1 rounded-full text-sm font-bold bg-gray-100 text-gray-500';
                badge.textContent = 'æŸ¥çœ‹è©³æƒ…';
            }
            
            if (msgEl && result.msg) {
                msgEl.textContent = result.msg;
            }
        }

        updateWidget();
        setInterval(updateWidget, 60000);
    </script>
    </div>
) : null}
